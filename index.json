[{"content":"1. 例题 给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。模板串 P 在模式串 S 中多次作为子串出现，求出模板串 P 在模式串 S 中所有出现的位置的起始下标。\n2. next 数组 在 KMP 算法中，通常使字符串首字符位于下标为 1 的位置。如，对于模板串 P ：\u0026ldquo;abcdabd\u0026rdquo;，有\n   index 0 1 2 3 4 5 6 7     P  a b c d a b d   nxt 0 0 0 0 0 1 2 0    其中，next 数组初始可使 nxt[0] 和 nxt[1] 均为 0，后续值可采用如下算法计算：\nchar p[n+2]{}; // scanf(\u0026#34;%s\u0026#34;, p+1); or cin \u0026gt;\u0026gt; p+1; int nxt[n+1]{}; void calNext() { for (int i = 2, j = 0; i \u0026lt;= n; ++i) { while (j \u0026amp;\u0026amp; p[i] != p[j+1]) { j = nxt[j]; } if (p[i] == p[j+1]) { ++j; } nxt[i] = j; } } 3. 模式串匹配 char s[m+2]{};\t// scanf(\u0026#34;%s\u0026#34;, s+1); or cin \u0026gt;\u0026gt; s+1;  void find() { for (int i = 1, j = 0; i \u0026lt;= m; ++i) { while (j \u0026amp;\u0026amp; s[i] != p[j+1]) { j = nxt[j]; } if (s[i] == p[j+1]) { ++j; } if (j == n) { // The pattern string has been found!  cout \u0026lt;\u0026lt; i - n \u0026lt;\u0026lt; endl; j = nxt[j]; } } } ","permalink":"https://lachimere.github.io/posts/algorithms/kmp/","summary":"next 数组和 KMP 算法模板","title":"KMP 算法模板"},{"content":"1. iota 的使用方式 iota 标识符仅能用于常量声明语句中，其取值与 const 语句块中代码的行数强相关。\nconst ( bit0, mask0 = 1 \u0026lt;\u0026lt; iota, 1 \u0026lt;\u0026lt; iota - 1\t// iota == 0, bit0 == 0001, mask == 0000  bit1, mask1\t// iota == 1, bit1 == 0010, mask == 0001  _, _\t// iota == 2  bit3, mask3\t// iota == 3, bit3 == 1000, mask == 0111 ) 2. iota 的取值规则 iota 的取值规则只有一条：iota 代表了 const 声明块的行索引（下标从 0 开始）。 const 声明的一个特点是，若为常量指定了一个表达式，而后续的常量没有表达式，则会继承上面的表达式。\n在单个const 声明块中，每增加一行声明，iota 的值增 1，即使声明中没有使用 iota。 由此也可知，在同一行中出现多个 iota，其取值是相同的。\nconst ( A = 100\t// iota == 0, A == 100  B\t// iota == 1, B == 100  C = iota\t// iota == 2, C == 2  D\t// iota == 3, D == 3  _\t// iota == 4  F\t// iota == 5, F == 5  G = 0\t// iota == 6, G == 0  H, I = 42 * iota, iota * iota + 3\t// iota == 7, H == 294, I == 52  J, K\t// iota == 8, J == 336, K == 67 ) ","permalink":"https://lachimere.github.io/posts/golang/%E7%90%86%E8%A7%A3iota%E7%9A%84%E5%8F%96%E5%80%BC%E8%A7%84%E5%88%99/","summary":"iota 的取值究竟是什么？","title":"理解 iota 的取值规则"},{"content":"1. Slice 定义 在 Go 的源码包中，src/runtime/slice.go 定义了 slice 的数据结构：\ntype slice struct { array unsafe.Pointer len int cap int } 其中，array 指向底层数组，len 为 slice 长度，cap 为底层数组容量。\n2. Slice 多种初始化方式的异同   使用变量声明\nvar s []int 当采用这种方式声明一个 slice 的时候，需要注意：\n s 是结构体 slice 的一个实例，其 fields 中 len 和 cap 均为 0，而 array 为 nil； 若输出 s，即 fmt.Println(s)，输出结果为 []； s == nil 为 true，但 \u0026amp;s 会显示一个有效的地址值，表明 s 已存在于内存中。    使用字面量初始化\n初始化一个空 slice：\ns := []int{} 此时，s 的 len 和 cap 也均为 0，但 array 不为 nil。虽然 fmt.Println(s) 仍会输出 []，但 s == nil 为 false。\n  使用内置函数 make() 可指定长度和空间\ns1 := make([]int, 5)\t// 指定长度 s2 := make([]int, 5, 10)\t// 指定长度和空间   从 array 或 slice 中切取\narr := [5]int{1, 2, 3, 4, 5} s1 := arr[0:2]\t// len(s1) == 2, cap(s1) == 5 s2 := s1[0:1]\t// len(s2) == 1, cap(s2) == 5 在本例中，s1 由 array arr 切取得到，s2 由 s1 切取得到，可验证 \u0026amp;arr == \u0026amp;s1[0] 和 \u0026amp;arr == \u0026amp;s2[0]。\n  3. 调用 append() 时需保持清醒 append() 扩容容量选择基于以下基本规则：\n 若 old.cap \u0026lt; 1024，则 slice 容量扩大为原来的 2 倍； 若 old.cap \u0026gt;= 1024，则 slice 容量扩大为原来的 1.25 倍。  在使用 append() 向 slice 中加入元素时，若 slice 空间不足，即当新加入的元素会使得 len \u0026gt; cap 时，slice 会通过 growslice() 函数增长。值得注意的是，growslice() 函数是有返回值的，其返回值类型为 slice，故可将 slice 的增长过程认为是在内存中的另一区域开辟一块新的空间存放数据，并将这块空间的地址作为新的 array 指针，同时更新 cap，构造出 slice{p, old.len, newcap} 以返回。因此，每一次扩容理论上都会引起 slice 底层数组所在位置的变化。\n一个很值得研究的例子如下：\nfunc SliceRise(s []int) { s = append(s, 0) for i := range s { s[i]++ } } func SlicePrint() { s1 := []int{1, 2} s2 := s1 s2 = append(s2, 3) SliceRise(s1) SliceRise(s2) fmt.Println(s1, s2)\t// [1 2] [2 3 4] } 当程序调用 SlicePrint() 函数时，该函数前两行执行后，s1 和 s2 是 len 和 cap 均为 2 的 两个 slices，debug 发现，此时有 \u0026amp;s1 != \u0026amp;s2 且 \u0026amp;s1[0] == \u0026amp;s2[0]，说明 s1 和 s2 是两个不同的 slice 实例，但二者的 array 值均相等。当向 s2 中加入元素 3 时，由于 s2 需要扩容，故 s2 的 array 值被更新（重新分配了新的空间）且其 len 和 cap 值由 2 分别更新为 3 和 4。\n现讨论 s1。切记，Go 语言中函数参数传递均是 pass by value，故调用 SliceRise(s1) 时，在 SliceRise() 中相当于进行了 s := s1 的操作，这与 SlicePrint() 中 s2 := s1 所造成的结果是一致的。故在 callee SliceRise() 中进行 s = append(s, 0) 操作后，s 的底层数组空间重新分配，不再代表其 caller SlicePrint() 中 s1 的底层数组，因此对其中所有元素的操作不会修改 s1 底层数组中元素的值，s1 最后的输出结果仍为 [1 2]。\ns2 的情况更加隐蔽。由上可知，在调用 SliceRise(s2) 之前，s2 的底层数组容量已更新为 4, 而此时其中有效元素仅有 1 和 2。同样地，SliceRise() 中的 s 是 s2 的拷贝，但由于 s2 底层数组中尚有空间存放新增的元素，此时 s = append(s, 0) 不会导致 array 所指空间的重新分配，即此时 s 和 s2 共享同一底层数组 ，故在 callee SliceRise() 中修改 s 中元素便是修改 caller SlicePrint() 中 s2 的底层数组元素。因此，caller 中 s2 底层数组的四个元素值分别更新为 2 3 4 1。但是，正是由于 pass by value，callee 中的 s 即使通过 append() 向 s2 的底层数组新加入了一个元素，其所更新的 len 是属于 s 的，这不会影响 caller 中 s2 的 len，故 s2 的 len 仍为 3，因此 s2 最后输出结果为 [2 3 4]。\n综上，即使有多个 slice 实例共享同一个底层数组，每个 slice 在进行 append() 操作时，只会修改其自身的 len 和 cap，且当其需要扩容时，只会将其与共享的底层数组解引用，并为其分配新的底层数组空间。在修改共享的底层数组元素时，会影响到所有共享此底层数组的 slice。\n","permalink":"https://lachimere.github.io/posts/golang/%E6%B7%B1%E5%85%A5%E8%AE%A8%E8%AE%BAslice/","summary":"对 slice 的初始化方式之间的异同点和调用 append() 的具体细节的一些讨论。","title":"深入讨论 Slice"}]