[{"content":"计算机网络  HTTP 状态码 301 和 302 的区别？如何处理 301 和 302？ HTTP 2 和 HTTP 1.1 的区别  操作系统 数据库   隔离级别\n  MySQL 存储引擎 InnoDB 和 MyISAM 对比\n    InnoDB MyISAM     外键 支持 不支持   事务 支持 不支持   行表锁 行锁，操作时只锁某一行，适合高并发的操作 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作   缓存 不仅缓存索引还要缓存真实数据 只缓存索引，不缓存真实数据   表空间 小 大      B+ 树链表的作用\n在范围查找时效率比 B 树高，因为 B+ 树的叶子节点通过有序链表连接，而 B 树要实现范围查找需要通过中序遍历才能完成。\n  MySQL 索引\n 索引（Index）时帮助 MySQL 高效获取数据的数据结构。 索引的目的在于提高查询效率 索引是在存储引擎（storage engine）层面实现的    程序语言 C++  unordered_map 和 unordered_set 如何解决 hash 冲突 vector 扩容和缩容的实现  Golang  channel 的底层实现 map 的底层实现 context 相关  数据结构与算法 1. 堆排序 (Golang container/heap.go 实现) package heap import \u0026#34;sort\u0026#34; type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() \tPop() interface{} // remove and return element Len() - 1. } func Init(h Interface) { // heapify \tn := h.Len() for i := n/2 - 1; i \u0026gt;= 0; i-- { down(h, i, n) } } func Push(h Interface, x interface{}) { h.Push(x) up(h, h.Len()-1) } func Pop(h Interface) interface{} { n := h.Len() - 1 h.Swap(0, n) down(h, 0, n) return h.Pop() } func up(h Interface, j int) { for { i := (j - 1) / 2 // parent \tif i == j || !h.Less(j, i) { break } h.Swap(i, j) j = i } } func down(h Interface, i0, n int) bool { i := i0 for { j1 := 2*i + 1 if j1 \u0026gt;= n || j1 \u0026lt; 0 { // j1 \u0026lt; 0 after int overflow \tbreak } j := j1 // left child \tif j2 := j1 + 1; j2 \u0026lt; n \u0026amp;\u0026amp; h.Less(j2, j1) { j = j2 // = 2*i + 2 // right child \t} if !h.Less(j, i) { break } h.Swap(i, j) i = j } return i \u0026gt; i0 } // Remove removes and returns the element at index i from the heap. // The complexity is O(log n) where n = h.Len(). func Remove(h Interface, i int) interface{} { n := h.Len() - 1 if n != i { h.Swap(i, n) if !down(h, i, n) { up(h, i) } } return h.Pop() } // Fix re-establishes the heap ordering after the element at index i has changed its value. // Changing the value of the element at index i and then calling Fix is equivalent to, // but less expensive than, calling Remove(h, i) followed by a Push of the new value. // The complexity is O(log n) where n = h.Len(). func Fix(h Interface, i int) { if !down(h, i, h.Len()) { up(h, i) } } 对 int 型 slice 建小根堆示例：\ntype IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice\u0026#39;s length, \t// not just its contents. \t*h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[:n-1] return x } func Example_intHeap() { h := \u0026amp;IntHeap{2, 1, 5} heap.Init(h) heap.Push(h, 3) fmt.Printf(\u0026#34;minimum: %d\\n\u0026#34;, (*h)[0]) for h.Len() \u0026gt; 0 { fmt.Printf(\u0026#34;%d \u0026#34;, heap.Pop(h)) } // Output: \t// minimum: 1 \t// 1 2 3 5 } 2. LeetCode 152. Maximum Product Subarray 3. LeetCode 238. Product of Array Except Self ","permalink":"https://lachimere.github.io/posts/interview/","summary":"面经笔记","title":"Interview Notes"},{"content":"1. merge 函数 merge 负责实现归并的过程，代码如下：\nfunc merge(values, aux []int, left, mid, right int) { i, j := left, mid+1 for k := left; k \u0026lt;= right; k++ { if j \u0026gt; right || (i \u0026lt;= mid \u0026amp;\u0026amp; values[i] \u0026lt;= values[j]) { aux[k] = values[i] i++ } else { aux[k] = values[j] j++ } } for k := left; k \u0026lt;= right; k++ { values[k] = aux[k] } } 其中，values 为待排序 slice，aux 为辅助数组，长度与 values 相等。\n2. 自顶向下归并排序 func MergeSortTopDown(values []int) { n := len(values) aux := make([]int, n) var mergeSort func(values, aux []int, left, right int) mergeSort = func(values, aux []int, left, right int) { if left \u0026gt;= right { return } mid := (left + right) \u0026gt;\u0026gt; 1 mergeSort(values, aux, left, mid) mergeSort(values, aux, mid + 1, right) merge(values, aux, left, mid, right) } mergeSort(values, aux, 0, n-1) } 3. 自底向上归并排序 func MergeSortBottomUp(values []int) { n := len(values) aux := make([]int, n) for sz := 1; sz \u0026lt; n; sz \u0026lt;\u0026lt;= 1 { for left := 0; left \u0026lt; n; left += sz \u0026lt;\u0026lt; 1 { mid, right := left+sz-1, maths.MinInt(left+2*sz-1, n-1) merge(values, aux, left, mid, right) } } } 其中，maths.MinInt 为自定义的 int 类型比较函数：\nfunc MinInt(a, b int) int { if a \u0026lt; b { return a } return b } 4. 自底向上的归并排序可用于实现链表的原地归并排序 例题：LeetCode 148. 排序链表\n链表节点定义如下：\ntype ListNode struct { Val int Next *ListNode } split 函数用于分段，并返回待归并的两段链表中的第二段：\nfunc split(head *ListNode, n int) *ListNode { for i := 1; i \u0026lt; n \u0026amp;\u0026amp; head != nil; i++ { head = head.Next } if head == nil { return nil } second := head.Next head.Next = nil return second } merge 函数归并已排序的两段链表，并返回归并后的链表的尾节点：\nfunc merge(left, right *ListNode, head *ListNode) *ListNode { cur := head for left != nil \u0026amp;\u0026amp; right != nil { if left.Val \u0026lt;= right.Val { cur.Next = left left = left.Next } else { cur.Next = right right = right.Next } cur = cur.Next } if left != nil { cur.Next = left } else { cur.Next = right } for cur.Next != nil { cur = cur.Next } return cur } 排序算法 sortList 实现如下：\nfunc sortList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } n := 0 for cur := head; cur != nil; cur = cur.Next { n++ } dummy := \u0026amp;ListNode{Val: -1, Next: head} var left, right, tail *ListNode for sz := 1; sz \u0026lt; n; sz \u0026lt;\u0026lt;= 1 { cur := dummy.Next tail = dummy for cur != nil { left = cur right = split(left, sz) cur = split(right, sz) tail = merge(left, right, tail) } } return dummy.Next } ","permalink":"https://lachimere.github.io/posts/algorithms/mergesort/","summary":"Go 语言实现自顶向下与自底向上的归并排序","title":"MergeSort in Golang"},{"content":"Arrays, slices (and strings): The mechanics of \u0026lsquo;append\u0026rsquo; Rob Pike, 26 Semptember 2013\n数组、切片（和字符串）——append 的方法\nLaChimere 译\nIntroduction 简介\nOne of the most common features of procedural programming languages is the concept of an array. Arrays seem like simple things but there are many questions that must be answered when adding them to a language, such as:\n fixed-size or variable-size? is the size part of the type? what do multidimensional arrays look like? does the empty array have meaning?  过程式编程语言最为普遍的特点之一是数组的概念。虽然数组看似简单，但在将其引入到程序语言时，有如下许多问题必须解决：\n 数组大小是否固定？ 数组大小是否为数组类型的一部分？ 多维数组是什么样子？ 空数组是否具有意义？  The answers to these questions affect whether arrays are just a feature of the language or a core part of its design.\n对于一个程序语言，上述问题的答案将会影响数组仅作为其特性之一还是作为其核心组成部分。\nIn the early development of Go, it took about a year to decide the answers to these questions before the design felt right. The key step was the introduction of slices, which built on fixed-size arrays to give a flexible, extensible data structure. To this day, however, programmers new to Go often stumble over the way slices work, perhaps because experience from other languages has colored their thinking.\n在 Go 语言早期开发时期，我们在将数组设计得基本正确之前，经历了大约一年的时间来回答这些问题。其中，最为重要的一步便是对于 slice（切片）的引入。Slice 建立在固定大小的 array （数组）之上，是一种灵活且具有扩展性的数据结构。然而，时至今日，或许是受到了其他程序语言的影响，初学 Go 语言的程序员在理解 slice 工作方式上常常遇到困难。\nIn this post we\u0026rsquo;ll attempt to clear up the confusion. We\u0026rsquo;ll do so by building up the pieces to explain how the append built-in function works, and why it works the way it does.\n为了消除这样的疑惑，在本文中，我们将通过例子来阐明 append 如何运行和它为何按照此方式运行的问题。\nArrays 数组\nArrays are an important building block in Go, but like the foundation of a building they are often hidden below more visible components. We must talk about them briefly before we move on to the more interesting, powerful, and prominent idea of slices.\nArray 是 Go 语言的重要组成部分之一，但如地基一般，数组常常隐藏在其他可见的组成背后。在介绍更为有趣、强大和著名的 slice 之前，我们必须先简要介绍一下 array。\nArrays are not often seen in Go programs because the size of an array is part of its type, which limits its expressive power.\n由于固定的大小限制了其表现力，array 并不常为 Go 程序员使用。\nThe declaration\n如下声明了一个 256 字节大小的 buffer 数组。\nvar buffer [256]byte declares the variable buffer, which holds 256 bytes. The type of buffer includes its size, [256]byte. An array with 512 bytes would be of the distinct type [512]byte.\nbuffer 的类型，即 [256]byte，包含了其大小。那么一个 512 字节大小的数组的类型可为 [512]byte。\nThe data associated with an array is just that: an array of elements. Schematically, our buffer looks like this in memory,\n与一个数组相联系的数据就是“数组的元素”。简要地讲，我们的 buffer 在内存中就像下面这样：\nbuffer: byte byte byte ... 256 times ... byte byte byte That is, the variable holds 256 bytes of data and nothing else. We can access its elements with the familiar indexing syntax, buffer[0], buffer[1], and so on through buffer[255]. (The index range 0 through 255 covers 256 elements.) Attempting to index buffer with a value outside this range will crash the program.\n这表明，变量 buffer 只保存着 256 字节的数据。我们可以用熟悉的索引方式来访问其中的元素，如 buffer[0]、buffer[1] 直到 buffer[255]。（数组下标从 0 到 255 表示共 256 个元素）越界访问 buffer 数组会导致程序崩溃。\nThere is a built-in function called len that returns the number of elements of an array or slice and also of a few other data types. For arrays, it\u0026rsquo;s obvious what len returns. In our example, len(buffer) returns the fixed value 256.\n内置函数 len 会返回 array 或 slice 等数据类型的元素个数。对于 array 来说 len 所返回的结果显而易见，在上述例子中，len(buffer) 将返回一个固定的值 256。\nArrays have their place—they are a good representation of a transformation matrix for instance—but their most common purpose in Go is to hold storage for a slice.\nArray 具有自己的空间，可以很好地表示出变换矩阵等。然而，array 在 Go 语言中最为普遍的用途是为 slice 提供存储空间（译注：即作为 slice 的底层数组）。\nSlices: The slice header 切片：slice header\nSlices are where the action is, but to use them well one must understand exactly what they are and what they do.\nSlice 是我们常用来操作的类型，但只有准确地理解 slice 及其功能我们才能用好它。\nA slice is a data structure describing a contiguous section of an array stored separately from the slice variable itself. A slice is not an array. A slice describes a piece of an array.\nSlice 是用来描述数组上的一段连续片段的数据结构，该片段与 slice 是分开存储的。Slice 并非 array，它描述了 array 的一个片段。\nGiven our buffer array variable from the previous section, we could create a slice that describes elements 100 through 150 (to be precise, 100 through 149, inclusive) by slicing the array:\n我们可以给此前提到的 buffer 数组进行切片以创建一个 slice 来描述其第 100 ~ 150 个元素（准确地说，是第 100 个到 第 149 个元素，闭区间）：\nvar slice []byte = buffer[100:150] In that snippet we used the full variable declaration to be explicit. The variable slice has type []byte, pronounced \u0026ldquo;slice of bytes\u0026rdquo;, and is initialized from the array, called buffer, by slicing elements 100 (inclusive) through 150 (exclusive). The more idiomatic syntax would drop the type, which is set by the initializing expression:\n上述代码中，我们显式地对声明了变量。变量 slice 的类型为 []byte，即 byte 的切片。同时，slice 也通过对 buffer 数组的第 $[100, 150)$ 个元素切片而进行了初始化，更为习惯的用法是省略掉 slice 的类型而用初始化表达式来推断，如下：\nvar slice = buffer[100:150] Inside a function we could use the short declaration form,\n在函数中我们可使用如下短声明式：\nslice := buffer[100:150] What exactly is this slice variable? It\u0026rsquo;s not quite the full story, but for now think of a slice as a little data structure with two elements: a length and a pointer to an element of an array. You can think of it as being built like this behind the scenes:\nSlice 变量究竟是什么？现在我们还没有完全回答这个问题，不过你可以将 slice 设想为一个具有两种元素的数据结构：长度 length 和指向存放数据元素数组的指针 pointer，就像下面这样：\ntype sliceHeader struct { Length int ZerothElement *byte } slice := sliceHeader{ Length: 50, ZerothElement: \u0026amp;buffer[100], } Of course, this is just an illustration. Despite what this snippet says that sliceHeader struct is not visible to the programmer, and the type of the element pointer depends on the type of the elements, but this gives the general idea of the mechanics.\n当然，这只是一种说明。尽管在这个代码块中，sliceHeader 对程序员而言不可见，且其中的数据元素指针类型取决于数据元素类型，但这是对 slice 实现方法的一个大体的说明。\nSo far we\u0026rsquo;ve used a slice operation on an array, but we can also slice a slice, like this:\n除了可以对 array 进行操作，我们像下面这样还可以对 slice 进行切片：\nslice2 := slice[5:10] Just as before, this operation creates a new slice, in this case with elements 5 through 9 (inclusive) of the original slice, which means elements 105 through 109 of the original array. The underlying sliceHeader struct for the slice2 variable looks like this:\n如此前一样，这样的操作将会创建一个新的 slice。在上面这个例子中，新的 slice 表示原始 slice 中的第 $[5,9]$ 个元素，即原 array 中的第 $[105,109]$ 个元素。对于 slice2 而言，底层的 sliceHeader 像这样：\nslice2 := sliceHeader{ Length: 5, ZerothElement: \u0026amp;buffer[105], } Notice that this header still points to the same underlying array, stored in the buffer variable.\n请注意，这个 sliceHeader 依然指向同一底层数组，即 buffer。\nWe can also reslice, which is to say slice a slice and store the result back in the original slice structure. After\n我们还可以对一个 slice 再分片，并且可以将分片的结果存放于原 slice 中。\nslice = slice[5:10] the sliceHeader structure for the slice variable looks just like it did for the slice2 variable. You\u0026rsquo;ll see reslicing used often, for example to truncate a slice. This statement drops the first and last elements of our slice:\n在对 slice 进行上面的操作后，slice 的 sliceHeader 结构与此前对 slice2 进行再切片操作后的 sliceHeader 类似。你会发现，再分片的操作时常用到，例如截取 slice，如下语句便截掉了 slice 的首尾元素：\nslice = slice[1:len(slice)-1] [Exercise: Write out what the sliceHeader struct looks like after this assignment.]\n【练习：写出上面赋值语句操作过后的 sliceHeader 结构。】\nYou\u0026rsquo;ll often hear experienced Go programmers talk about the \u0026ldquo;slice header\u0026rdquo; because that really is what\u0026rsquo;s stored in a slice variable. For instance, when you call a function that takes a slice as an argument, such as bytes.IndexRune, that header is what gets passed to the function. In this call,\n你会常常听到经验丰富的 Go 程序员讨论“slice header”，这是因为“slice header”是 slice 变量真正存储的内容。举个例子，当你想要将 slice 作为参数去调用一个函数时，如 bytes.IndexRune，“slice header”是真正传给函数的参数。在如下函数调用中，\nslashPos := bytes.IndexRune(slice, \u0026#39;/\u0026#39;) the slice argument that is passed to the IndexRune function is, in fact, a \u0026ldquo;slice header\u0026rdquo;.\n传递给函数 IndexRune 的 slice 参数实际上是一个“slice header”。\nThere\u0026rsquo;s one more data item in the slice header, which we talk about below, but first let\u0026rsquo;s see what the existence of the slice header means when you program with slices.\n我们将会在下面讨论 slice header 中另一个数据元素，不过在此之前，我们不妨先看看在涉及 slice 的编程中 slice header 的存在意味着什么。\nPassing slices to functions 传函数以 slice\nIt\u0026rsquo;s important to understand that even though a slice contains a pointer, it is itself a value. Under the covers, it is a struct value holding a pointer and a length. It is not a pointer to a struct.\n尽管 slice 包含一个 指针 pointer，但 slice 自身是一个值，理解这一点非常重要。在 Go 语言内部，slice 实际上是一个保存着指针 pointer 和 长度 length 的结构体，而非单纯的指向另一种结构的指针。\nThis matters.\n这一点非常重要。\nWhen we called IndexRune in the previous example, it was passed a copy of the slice header. That behavior has important ramifications.\n在此前的例子中，当我们调用 IndexRune 函数时，我们传给该函数一个 slicer header 的拷贝，这样的行为会产生意义重大而又难以预测的结果。\nConsider this simple function:\n如下函数：\nfunc AddOneToEachElement(slice []byte) { for i := range slice { slice[i]++ } } It does just what its name implies, iterating over the indices of a slice (using a for range loop), incrementing its elements.\n该函数功能如其名，递增 slice 中每一个元素。\nTry it:\n尝试运行下面这段代码：\nfunc main() { slice := buffer[10:20] for i := 0; i \u0026lt; len(slice); i++ { slice[i] = byte(i) } fmt.Println(\u0026#34;before\u0026#34;, slice) AddOneToEachElement(slice) fmt.Println(\u0026#34;after\u0026#34;, slice) } (You can edit and re-execute these runnable snippets if you want to explore.)\n（想要探究的话，你可以编辑并且再次执行这段代码。）\nEven though the slice header is passed by value, the header includes a pointer to elements of an array, so both the original slice header and the copy of the header passed to the function describe the same array. Therefore, when the function returns, the modified elements can be seen through the original slice variable.\n虽然 slice header 以传值（pass by value）的方式传递给函数，但 slice header 中所含的的指针指向元素数组，因此原 slice header 及其传递给函数的拷贝描述着同一个数组，故当函数返回时，我们可以通过原 slice 变量观察到元素已发生了修改。\nThe argument to the function really is a copy, as this example shows:\n下面代码印证了传递给函数的 slice 参数实际上是原 slice 的一个拷贝：\nfunc SubtractOneFromLength(slice []byte) []byte { slice = slice[0 : len(slice)-1] return slice } func main() { fmt.Println(\u0026#34;Before: len(slice) =\u0026#34;, len(slice)) newSlice := SubtractOneFromLength(slice) fmt.Println(\u0026#34;After: len(slice) =\u0026#34;, len(slice)) fmt.Println(\u0026#34;After: len(newSlice) =\u0026#34;, len(newSlice)) } Here we see that the contents of a slice argument can be modified by a function, but its header cannot. The length stored in the slice variable is not modified by the call to the function, since the function is passed a copy of the slice header, not the original. Thus if we want to write a function that modifies the header, we must return it as a result parameter, just as we have done here. The slice variable is unchanged but the returned value has the new length, which is then stored in newSlice,\n在此我们可以看到，slice 参数的内容可以为函数所修改，但其 header 却不能被修改。存放在 slice 变量中的长度 length 在函数调用后并未发生修改，这是因为我们是将 slice header 的拷贝而非原 slice header 传递给了函数。因此，如果我们想要在函数中修改 slice header，我们必须将 slice header 作为结果返回，如 SubstractOneFromLength 所做的那样。slice 变量没有发生改变，但函数所返回的值 newSlice 中保存了新的长度 length。\nPointers to slices: Method receivers 指向 slice 的指针：方法的 receiver\nAnother way to have a function modify the slice header is to pass a pointer to it. Here\u0026rsquo;s a variant of our previous example that does this:\n另一种通过函数修改 slice header 的方式是传指针。下面我们将此前的例子进行了一些变化：\nfunc PtrSubtractOneFromLength(slicePtr *[]byte) { slice := *slicePtr *slicePtr = slice[0 : len(slice)-1] } func main() { fmt.Println(\u0026#34;Before: len(slice) =\u0026#34;, len(slice)) PtrSubtractOneFromLength(\u0026amp;slice) fmt.Println(\u0026#34;After: len(slice) =\u0026#34;, len(slice)) } It seems clumsy in that example, especially dealing with the extra level of indirection (a temporary variable helps), but there is one common case where you see pointers to slices. It is idiomatic to use a pointer receiver for a method that modifies a slice.\n此例虽看上去挺笨拙的，尤其是通过一个临时变量来辅助我们间接访问 slice，但它的确是使用指向 slice 的指针时一种较为普遍的情形。我们习惯上用一个指针类型的 receiver 来调用方法以修改 slice。\nLet\u0026rsquo;s say we wanted to have a method on a slice that truncates it at the final slash. We could write it like this:\n比如，我们可以像如下代码这样通过调用一个方法实现截取 slice 最后一个 / 之前的 slice：\ntype path []byte func (p *path) TruncateAtFinalSlash() { i := bytes.LastIndex(*p, []byte(\u0026#34;/\u0026#34;)) if i \u0026gt;= 0 { *p = (*p)[0:i] } } func main() { pathName := path(\u0026#34;/usr/bin/tso\u0026#34;) // Conversion from string to path.  pathName.TruncateAtFinalSlash() fmt.Printf(\u0026#34;%s\\n\u0026#34;, pathName) } If you run this example you\u0026rsquo;ll see that it works properly, updating the slice in the caller.\n跑一跑这段代码你会发现它能够通过调用函数正确地更新 slice。\n[Exercise: Change the type of the receiver to be a value rather than a pointer and run it again. Explain what happens.]\n【练习：将 receiver 的类型从指针改为值，再跑一跑试试，并解释所发生的现象。】\nOn the other hand, if we wanted to write a method for path that upper-cases the ASCII letters in the path (parochially ignoring non-English names), the method could be a value because the value receiver will still point to the same underlying array.\n不过，当我们想要用设计一个 path 的方法来将其中的 ASCII 字母转换为大写时（其余的非英文字母均忽略），该方法的 receiver 可以为值，这是因为以值表示的 receiver 所指向底层数组和原 slice 所指向的底层数组是同一个。\ntype path []byte func (p path) ToUpper() { for i, b := range p { if \u0026#39;a\u0026#39; \u0026lt;= b \u0026amp;\u0026amp; b \u0026lt;= \u0026#39;z\u0026#39; { p[i] = b + \u0026#39;A\u0026#39; - \u0026#39;a\u0026#39; } } } func main() { pathName := path(\u0026#34;/usr/bin/tso\u0026#34;) pathName.ToUpper() fmt.Printf(\u0026#34;%s\\n\u0026#34;, pathName) } Here the ToUpper method uses two variables in the for range construct to capture the index and slice element. This form of loop avoids writing p[i] multiple times in the body.\n这里的 ToUpper 方法在 for range 语句中取得了 slice 的下标和与之对应的元素，这种形式可以避免在函数体中出现多次 p[i]。\n[Exercise: Convert the ToUpper method to use a pointer receiver and see if its behavior changes.]\n【练习：将 ToUpper 方法改用为指针类型的 receiver 来调用，看看会发生什么变化。】\n[Advanced exercise: Convert the ToUpper method to handle Unicode letters, not just ASCII.]\n【进阶练习：将 ToUpper 改为可以处理 Unicode 字符而非仅局限于 ASCII 的方法。】\nCapacity 容量\nLook at the following function that extends its argument slice of ints by one element:\n我们先来看看下面这个函数，在此函数中，我们给传入的 slice 参数扩展了空间：\nfunc Extend(slice []int, element int) []int { n := len(slice) slice = slice[0 : n+1] slice[n] = element return slice } (Why does it need to return the modified slice?) Now run it:\n（为什么这个函数需要返回修改了的 slice？）现在我们运行看看：\nfunc main() { var iBuffer [10]int slice := iBuffer[0:0] for i := 0; i \u0026lt; 20; i++ { slice = Extend(slice, i) fmt.Println(slice) } } See how the slice grows until\u0026hellip; it doesn\u0026rsquo;t.\n看看它会增长到······好吧它不会。\nIt\u0026rsquo;s time to talk about the third component of the slice header: its capacity. Besides the array pointer and length, the slice header also stores its capacity:\n是时候来讨论下 slice header 的第三个组成部分了——容量（capacity）。除了指向数组的指针和长度外，slice header 还保存了它的容量：\ntype sliceHeader struct { Length int Capacity int ZerothElement *byte } The Capacity field records how much space the underlying array actually has; it is the maximum value the Length can reach. Trying to grow the slice beyond its capacity will step beyond the limits of the array and will trigger a panic.\nCapacity 记录了底层数组的实际空间大小，它是 Length 能够达到的最大值。想要将 slice 增长到超过它的 capacity 将会导致数组越界，从而引发 panic。\nAfter our example slice is created by\n在我们的例子中 slice 是如是创建的：\nslice := iBuffer[0:0] its header looks like this:\n它的 header 就像这样：\nslice := sliceHeader{ Length: 0, Capacity: 10, ZerothElement: \u0026amp;iBuffer[0], } The Capacity field is equal to the length of the underlying array, minus the index in the array of the first element of the slice (zero in this case). If you want to inquire what the capacity is for a slice, use the built-in function cap:\nCapacity 与底层数组的长度减去 slice 首元素在 array 中的下标（此例中为 0）所得的差相等。你可以调用内置函数 cap 来得到一个 slice 的 capacity：\nif cap(slice) == len(slice) { fmt.Println(\u0026#34;slice is full!\u0026#34;) } Make make\nWhat if we want to grow the slice beyond its capacity? You can\u0026rsquo;t! By definition, the capacity is the limit to growth. But you can achieve an equivalent result by allocating a new array, copying the data over, and modifying the slice to describe the new array.\n如果我们想要将 slice 增长到超过其 capacity 的大小会怎么样呢？不行的！在定义上，capacity 限制了 slice 的增长，但你可以通过一种等价的方式来达到此目的，即分配一个新的数组，将数据复制过去，再修改 slice 以令其来描述新分配的数组。\nLet\u0026rsquo;s start with allocation. We could use the new built-in function to allocate a bigger array and then slice the result, but it is simpler to use the make built-in function instead. It allocates a new array and creates a slice header to describe it, all at once. The make function takes three arguments: the type of the slice, its initial length, and its capacity, which is the length of the array that make allocates to hold the slice data. This call creates a slice of length 10 with room for 5 more (15-10), as you can see by running it:\n先来说说分配的事。我们可以通过内置函数 new 来分配一个更大的数组并将其切片，但更为简单的做法是使用内置函数 make。make 能够一次性分配一个新的数组并创建描述此数组的 slice header。make 函数有三个参数：slice 的类型、初始长度和 capacity，其中 capacity 即为 make 为 slice 所分配的数组的长度。下面的代码创建了一个初始长度为 10 且具有 5 个 （$15-10$）可增长空间的 slice，来跑跑看：\nslice := make([]int, 10, 15) fmt.Printf(\u0026#34;len: %d, cap: %d\\n\u0026#34;, len(slice), cap(slice)) This snippet doubles the capacity of our int slice but keeps its length the same:\n下面的代码块将我们上面的 int 型 slice 的 capacity 翻倍，但长度保持不变：\nslice := make([]int, 10, 15) fmt.Printf(\u0026#34;len: %d, cap: %d\\n\u0026#34;, len(slice), cap(slice)) newSlice := make([]int, len(slice), 2*cap(slice)) for i := range slice { newSlice[i] = slice[i] } slice = newSlice fmt.Printf(\u0026#34;len: %d, cap: %d\\n\u0026#34;, len(slice), cap(slice)) After running this code the slice has much more room to grow before needing another reallocation.\n运行上面的代码后，slice 在重新分配空间之前将有更多可增长的空间。\nWhen creating slices, it\u0026rsquo;s often true that the length and capacity will be same. The make built-in has a shorthand for this common case. The length argument defaults to the capacity, so you can leave it out to set them both to the same value. After\n当创建 slice 时，slice 的长度和 capacity 常常是相等的，这种情况下在 make 中不必写出 capacity，因为其 capacity 的值默认为 length 参数的值。\ngophers := make([]Gopher, 10) the gophers slice has both its length and capacity set to 10.\n上面的代码将 gophers slice 的长度和 capacity 均设为 10。\nCopy copy\nWhen we doubled the capacity of our slice in the previous section, we wrote a loop to copy the old data to the new slice. Go has a built-in function, copy, to make this easier. Its arguments are two slices, and it copies the data from the right-hand argument to the left-hand argument. Here\u0026rsquo;s our example rewritten to use copy:\n在前面我们将 slice 的 capacity 翻倍后，我们写了一个循环来将原先的数据拷贝到新 slice 中。对此，Go 语言提供了内置函数 copy 来简化我们的操作。copy 有两个参数，第一个参数为目的参数，第二个为源参数。下面是使用 copy 的例子：\nnewSlice := make([]int, len(slice), 2*cap(slice)) copy(newSlice, slice) The copy function is smart. It only copies what it can, paying attention to the lengths of both arguments. In other words, the number of elements it copies is the minimum of the lengths of the two slices. This can save a little bookkeeping. Also, copy returns an integer value, the number of elements it copied, although it\u0026rsquo;s not always worth checking.\ncopy 函数很是聪明，请注意两个参数的长度，copy 函数只拷贝它能够拷贝的部分。也就是说，会被拷贝的元素数量是两个 slices 的长度的较小值，如此可以省去一些记录。此外，copy 会返回一个表示被拷贝的元素数量的整数，尽管这个数并不经常有用。\nThe copy function also gets things right when source and destination overlap, which means it can be used to shift items around in a single slice. Here\u0026rsquo;s how to use copy to insert a value into the middle of a slice.\ncopy 能够正确处理 src 和 dest 有相交部分的情况，这意味着我们可以在一个 slice 中使用 copy 来移动其中的元素。下面展示了如何利用 copy 向 slice 中插入一个值：\n// Insert inserts the value into the slice at the specified index, // which must be in range. // The slice must have room for the new element. func Insert(slice []int, index, value int) []int { // Grow the slice by one element.  slice = slice[0 : len(slice)+1] // Use copy to move the upper part of the slice out of the way and open a hole.  copy(slice[index+1:], slice[index:]) // Store the new value.  slice[index] = value // Return the result.  return slice } There are a couple of things to notice in this function. First, of course, it must return the updated slice because its length has changed. Second, it uses a convenient shorthand. The expression\n在上面的函数中有许多值得我们注意的点。首先，由于 slice 的长度发生了变化，该函数必须返回更新后的 slice。其次，在该函数中，我们使用了一种省事的写法：\nslice[i:] means exactly the same as\n它和下面的写法等价：\nslice[i:len(slice)] Also, although we haven\u0026rsquo;t used the trick yet, we can leave out the first element of a slice expression too; it defaults to zero. Thus\n虽然我们还没有用过这种小技巧，不过我们可以把起始下标省去，这样就默认从 0 开始。\nslice[:] just means the slice itself, which is useful when slicing an array. This expression is the shortest way to say \u0026ldquo;a slice describing all the elements of the array\u0026rdquo;:\n因此上方代码便表示 slice 自身，这在我们对 array 进行切片时是很有用的。这样的表达式极为简要地表现出“一个描述所有数组元素的 slice”的含义：\narray[:] Now that\u0026rsquo;s out of the way, let\u0026rsquo;s run our Insert function.\n现在回过头来运行一下我们的 Insert 函数。\nslice := make([]int, 10, 20) // Note capacity \u0026gt; length: room to add element.  for i := range slice { slice[i] = i } fmt.Println(slice) slice = Insert(slice, 5, 99) fmt.Println(slice) Append: An example append：一个例子\nA few sections back, we wrote an Extend function that extends a slice by one element. It was buggy, though, because if the slice\u0026rsquo;s capacity was too small, the function would crash. (Our Insert example has the same problem.) Now we have the pieces in place to fix that, so let\u0026rsquo;s write a robust implementation of Extend for integer slices.\n在前面的小节中，我们写了 Extend 函数来实现向 slice 扩展一个元素的功能，但这个函数是有 bug 的。如果 slice 的 capacity 过小，这个函数会导致程序崩溃。（Insert 例子也有相同的问题。）现在我们把之前的 Extend 函数拿来 fix bug，以实现出一个健壮的 Extend 函数。\nfunc Extend(slice []int, element int) []int { n := len(slice) if n == cap(slice) { // Slice is full; must grow.  // Slice 满了，必须增长。  // We double its size and add 1, so if the size is zero we still grow.  // 将 slice 的 capacity 倍增并加 1，这样若 size 为 0 也能正常增长。  newSlice := make([]int, len(slice), 2*len(slice)+1) copy(newSlice, slice) slice = newSlice } slice = slice[0 : n+1] slice[n] = element return slice } In this case it\u0026rsquo;s especially important to return the slice, since when it reallocates the resulting slice describes a completely different array. Here\u0026rsquo;s a little snippet to demonstrate what happens as the slice fills up:\n在上面的代码中，由于我们为所要得到的 slice 重新分配了底层数组，该数组与此前的底层数组完全不同，故返回 slice 极为重要。下面的代码佐证了当 slice 填满时所发生的情况：\nslice := make([]int, 0, 5) for i := 0; i \u0026lt; 10; i++ { slice = Extend(slice, i) fmt.Printf(\u0026#34;len=%d cap=%d slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) fmt.Println(\u0026#34;address of 0th element:\u0026#34;, \u0026amp;slice[0]) } Notice the reallocation when the initial array of size 5 is filled up. Both the capacity and the address of the zeroth element change when the new array is allocated.\n请注意，当初始化时的底层数组被填满后，我们需要重新分配底层数组，这时 slice 的 capacity 和首元素地址均发生了改变。\nWith the robust Extend function as a guide we can write an even nicer function that lets us extend the slice by multiple elements. To do this, we use Go\u0026rsquo;s ability to turn a list of function arguments into a slice when the function is called. That is, we use Go\u0026rsquo;s variadic function facility.\n借助上述健壮的 Extend 函数的引导，我们可以写出更棒的函数以实现扩展多个元素的功能。为了做到这一点，我们利用了 Go 语言的一个能力——在函数被调用时将一串参数转换为 slice，即可变参数函数机制。\nLet\u0026rsquo;s call the function Append. For the first version, we can just call Extend repeatedly so the mechanism of the variadic function is clear. The signature of Append is this:\n我们把可以实现向 slice 中扩展多个元素的函数叫做 Append。在其第一个实现版本中，我们先重复地调用 Extend，这样一来可变参数函数的机理显得较为清晰。Append 的函数签名如下：\nfunc Append(slice []int, items ...int) []int What that says is that Append takes one argument, a slice, followed by zero or more int arguments. Those arguments are exactly a slice of int as far as the implementation of Append is concerned, as you can see:\n这表明 Append 需要一个 slice 参数和零个或多个 int 型参数，在 Append 的实现中，这些 int 型参数与 int 型 slice 无异：\n// Append appends the items to the slice. // First version: just loop calling Extend. func Append(slice []int, items ...int) []int { for _, item := range items { slice = Extend(slice, item) } return slice } Notice the for range loop iterating over the elements of the items argument, which has implied type []int. Also notice the use of the blank identifier _ to discard the index in the loop, which we don\u0026rsquo;t need in this case.\n请注意，在 for range 循环中访问的 items 参数的隐式类型为 []int。此外，由于在此用不到下标，我们可用空白标识符 _ 忽略它们。\nTry it:\n试着运行：\nslice := []int{0, 1, 2, 3, 4} fmt.Println(slice) slice = Append(slice, 5, 6, 7, 8) fmt.Println(slice) Another new technique in this example is that we initialize the slice by writing a composite literal, which consists of the type of the slice followed by its elements in braces:\n从这个例子中我们可以学到一个新的技巧：在初始化 slice 的时候可以像下面这样在大括号中直接写出其所含的元素：\nslice := []int{0, 1, 2, 3, 4} The Append function is interesting for another reason. Not only can we append elements, we can append a whole second slice by \u0026ldquo;exploding\u0026rdquo; the slice into arguments using the ... notation at the call site:\nAppend 函数还有一点也很有趣，除了可以添加元素外，我们可以用 ... 符号将另一个 slice 打开而将其全部添加到 slice 中：\nslice1 := []int{0, 1, 2, 3, 4} slice2 := []int{55, 66, 77} fmt.Println(slice1) slice1 = Append(slice1, slice2...) // The \u0026#39;...\u0026#39; is essential!  fmt.Println(slice1) Of course, we can make Append more efficient by allocating no more than once, building on the innards of Extend:\n当然，我们可以将只分配至多一次空间以使得 Append 更加高效，在 Extend 中动动手脚：\n// Append appends the elements to the slice. // Efficient version. func Append(slice []int, elements ...int) []int { n := len(slice) total := len(slice) + len(elements) if total \u0026gt; cap(slice) { // Reallocate. Grow to 1.5 times the new size, so we can still grow.  newSize := total*3/2 + 1 newSlice := make([]int, total, newSize) copy(newSlice, slice) slice = newSlice } slice = slice[:total] copy(slice[n:], elements) return slice } Here, notice how we use copy twice, once to move the slice data to the newly allocated memory, and then to copy the appending items to the end of the old data.\n请注意两次 copy 是如何使用的，一次是把原 slice 的数据拷贝到新分配的 array 中，另一次是将要添加的元素拷贝到原数据的末尾处。\nTry it; the behavior is the same as before:\n试着跑一下，结果与此前相同：\nslice1 := []int{0, 1, 2, 3, 4} slice2 := []int{55, 66, 77} fmt.Println(slice1) slice1 = Append(slice1, slice2...) // The \u0026#39;...\u0026#39; is essential!  fmt.Println(slice1) Append: The built-in function 内置函数 append\nAnd so we arrive at the motivation for the design of the append built-in function. It does exactly what our Append example does, with equivalent efficiency, but it works for any slice type.\n目前，我们有足够的动力来设计内置函数 append 了。append 函数与此前的 Append 示例所做的事情一致，且同样高效，但它支持任意类型的 slice。\nA weakness of Go is that any generic-type operations must be provided by the run-time. Some day that may change, but for now, to make working with slices easier, Go provides a built-in generic append function. It works the same as our int slice version, but for any slice type.\n任意泛型操作都必须在运行时提供是 Go 语言的不足之一。或许有天这点会发生改变（译注：快了快了，Go 1.18 应该就支持泛型了），至少到目前为之，为了使得操作 slice 更为简单，Go 提供了通用的内置函数 append，它和我们 int 型 slice 版本的 Append 相同，但支持任意类型。\nRemember, since the slice header is always updated by a call to append, you need to save the returned slice after the call. In fact, the compiler won\u0026rsquo;t let you call append without saving the result.\n请记住，由于调用 append 总是会改变 slice header，你需要在调用 append 后保存其返回值。事实上，编译器要求你必须保存其返回值。\nHere are some one-liners intermingled with print statements. Try them, edit them and explore:\n下面是些关于调用 append 的例子，每次调用后会输出结果，运行并修改试试：\n// Create a couple of starter slices.  slice := []int{1, 2, 3} slice2 := []int{55, 66, 77} fmt.Println(\u0026#34;Start slice: \u0026#34;, slice) fmt.Println(\u0026#34;Start slice2:\u0026#34;, slice2) // Add an item to a slice.  slice = append(slice, 4) fmt.Println(\u0026#34;Add one item:\u0026#34;, slice) // Add one slice to another.  slice = append(slice, slice2...) fmt.Println(\u0026#34;Add one slice:\u0026#34;, slice) // Make a copy of a slice (of int).  slice3 := append([]int(nil), slice...) fmt.Println(\u0026#34;Copy a slice:\u0026#34;, slice3) // Copy a slice to the end of itself.  fmt.Println(\u0026#34;Before append to self:\u0026#34;, slice) slice = append(slice, slice...) fmt.Println(\u0026#34;After append to self:\u0026#34;, slice) It\u0026rsquo;s worth taking a moment to think about the final one-liner of that example in detail to understand how the design of slices makes it possible for this simple call to work correctly.\n上面的最后一个 append 例子值得花时间仔细思考一下，slice 的设计是如何使得这样的简单调用可行的。\nThere are lots more examples of append, copy, and other ways to use slices on the community-built \u0026ldquo;Slice Tricks\u0026rdquo; Wiki page.\n在 \u0026ldquo;Slice Tricks\u0026rdquo; Wiki page 上有许多使用 append、copy 和其他方式来操作 slice 的小技巧。\nNil nil\nAs an aside, with our newfound knowledge we can see what the representation of a nil slice is. Naturally, it is the zero value of the slice header:\n说句题外话，以我们新学到的知识，我们可以表示出 nil slice。自然地，该 slice 的 header 中的值均为其类型所对应的零值：\nsliceHeader{ Length: 0, Capacity: 0, ZerothElement: nil, } or just\n或写作\nsliceHeader{} The key detail is that the element pointer is nil too. The slice created by\n重点在于指向元素数组的指针也为 nil。如此创建的 slice\narray[0:0] has length zero (and maybe even capacity zero) but its pointer is not nil, so it is not a nil slice.\n长度为 0 （或许 capacity 也为 0）但其指针不为 nil （译注：指向 array），故其不为 nil slice。\nAs should be clear, an empty slice can grow (assuming it has non-zero capacity), but a nil slice has no array to put values in and can never grow to hold even one element.\n应当区分清楚的是，一个 空 slice 可以增长 （设其 capacity 不为 0），但一个 nil slice 不指向任何 array，故而无法增长以存储元素。\nThat said, a nil slice is functionally equivalent to a zero-length slice, even though it points to nothing. It has length zero and can be appended to, with allocation. As an example, look at the one-liner above that copies a slice by appending to a nil slice.\n也就是说，即使 nil slice 不指向任何数组，但其在功能上和零长 slice 等价。nil slice 长度为 0，且可以通过分配底层数组的方式向其中添加元素，例如上面 append 例子中的倒数第二个，即向 nil slice 中拷贝 slice 的元素。\nStrings 字符串\nNow a brief section about strings in Go in the context of slices.\n现在来简要介绍一下 Go 中字符串的 slice 背景。\nStrings are actually very simple: they are just read-only slices of bytes with a bit of extra syntactic support from the language.\n字符串真的很简单：它们是具有一些来自于 Go 语言额外句法支持的字节所组成的只读型 slice。\nBecause they are read-only, there is no need for a capacity (you can\u0026rsquo;t grow them), but otherwise for most purposes you can treat them just like read-only slices of bytes.\n由于字符串 slice 是只读的，因此就不需要 capacity 了（你也没法增长字符串），但对于绝大多数情况，你都可以将它们视作只读字节 slice 来处理。\nFor starters, we can index them to access individual bytes:\n首先，我们可以用下标访问其中某个字节：\nslash := \u0026#34;/usr/ken\u0026#34;[0] // yields the byte value \u0026#39;/\u0026#39;. We can slice a string to grab a substring:\n可以切片得到子串：\nusr := \u0026#34;/usr/ken\u0026#34;[0:4] // yields the string \u0026#34;/usr\u0026#34; It should be obvious now what\u0026rsquo;s going on behind the scenes when we slice a string.\n我们对字符串切片的背后究竟如何应当是显而易见的。\nWe can also take a normal slice of bytes and create a string from it with the simple conversion:\n我们还可以将一个普通的字节 slice 转换为字符串：\nstr := string(slice) and go in the reverse direction as well:\n也可反过来转换：\nslice := []byte(usr) The array underlying a string is hidden from view; there is no way to access its contents except through the string. That means that when we do either of these conversions, a copy of the array must be made. Go takes care of this, of course, so you don\u0026rsquo;t have to. After either of these conversions, modifications to the array underlying the byte slice don\u0026rsquo;t affect the corresponding string.\n字符串背后的底层数组是不可见的，除了通过字符串之外，我们没有办法访问该数组的内容。这意味着我们上述的转换都会引发对底层数组的拷贝。Go 对这一点十分在意，当然，你不必如此关心。在转换之后，对于字节 slice 的底层数组的修改不会影响其对应的字符串。\nAn important consequence of this slice-like design for strings is that creating a substring is very efficient. All that needs to happen is the creation of a two-word string header. Since the string is read-only, the original string and the string resulting from the slice operation can share the same array safely.\n如此设计类 slice 的字符串的重要影响是使得子串的创建很高效，这样的操作只需要创建具有两个元素的字符串 header。由于字符串是只读的，对于原字符串和经过 slice 操作后所得的字符串可以安全地共享同一数组。\nA historical note: The earliest implementation of strings always allocated, but when slices were added to the language, they provided a model for efficient string handling. Some of the benchmarks saw huge speedups as a result.\n历史注：最早期的字符串实现方式总是会分配空间，但当 slice 被引入到 Go 语言后，它为高效的字符串操作提供了范例，原先一些巨量的基准测试速度因此加快了。\nThere\u0026rsquo;s much more to strings, of course, and a separate blog post covers them in greater depth.\n有许多关于字符串的讨论，separate blog post 中更进一步涵盖了它们。\nConclusion 结论\nTo understand how slices work, it helps to understand how they are implemented. There is a little data structure, the slice header, that is the item associated with the slice variable, and that header describes a section of a separately allocated array. When we pass slice values around, the header gets copied but the array it points to is always shared.\n了解 slice 的运行方式能够帮助我们更好地理解它们的实现。在 Go 语言中，slice header 是一个小型的数据结构，元素与 slice 变量相联系，而 slice header 描述了与 slice 变量分开存储的所分配数组的片段。当我们传递 slice 的值的时候，slice header 会被拷贝，但其所指的底层数组总是共享的。\nOnce you appreciate how they work, slices become not only easy to use, but powerful and expressive, especially with the help of the copy and append built-in functions.\n当你领会了 slice 的运行方式之后，slice 不仅简单好用，而且强大并富有表现力，尤其是在与内置函数 copy 和 append 配合使用的时候。\nMore reading There\u0026rsquo;s lots to find around the intertubes about slices in Go. As mentioned earlier, the \u0026ldquo;Slice Tricks\u0026rdquo; Wiki page has many examples. The Go Slices blog post describes the memory layout details with clear diagrams. Russ Cox\u0026rsquo;s Go Data Structures article includes a discussion of slices along with some of Go\u0026rsquo;s other internal data structures.\nThere is much more material available, but the best way to learn about slices is to use them.\n","permalink":"https://lachimere.github.io/posts/golang/arrays-slices-and-strings-the-mechanics-of-append/","summary":"【The Go Blog】数组、切片（和字符串）——\u003ccode\u003eappend\u003c/code\u003e 的方法","title":"Arrays, slices (and strings): The mechanics of 'append'"},{"content":"1. 例题 给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。模板串 P 在模式串 S 中多次作为子串出现，求出模板串 P 在模式串 S 中所有出现的位置的起始下标。\n2. next 数组 在 KMP 算法中，通常使字符串首字符位于下标为 1 的位置。如，对于模板串 P ：\u0026ldquo;abcdabd\u0026rdquo;，有\n   index 0 1 2 3 4 5 6 7     P  a b c d a b d   nxt 0 0 0 0 0 1 2 0    其中，next 数组初始可使 nxt[0] 和 nxt[1] 均为 0，后续值可采用如下算法计算：\nchar p[n+2]{}; // scanf(\u0026#34;%s\u0026#34;, p+1); or cin \u0026gt;\u0026gt; p+1; int nxt[n+1]{}; void calNext() { for (int i = 2, j = 0; i \u0026lt;= n; ++i) { while (j \u0026amp;\u0026amp; p[i] != p[j+1]) { j = nxt[j]; } if (p[i] == p[j+1]) { ++j; } nxt[i] = j; } } 3. 模式串匹配 char s[m+2]{};\t// scanf(\u0026#34;%s\u0026#34;, s+1); or cin \u0026gt;\u0026gt; s+1;  void find() { for (int i = 1, j = 0; i \u0026lt;= m; ++i) { while (j \u0026amp;\u0026amp; s[i] != p[j+1]) { j = nxt[j]; } if (s[i] == p[j+1]) { ++j; } if (j == n) { // The pattern string has been found!  cout \u0026lt;\u0026lt; i - n \u0026lt;\u0026lt; endl; j = nxt[j]; } } } ","permalink":"https://lachimere.github.io/posts/algorithms/kmp/","summary":"next 数组和 KMP 算法模板","title":"KMP 算法模板"},{"content":"1. iota 的使用方式 iota 标识符仅能用于常量声明语句中，其取值与 const 语句块中代码的行数强相关。\nconst ( bit0, mask0 = 1 \u0026lt;\u0026lt; iota, 1 \u0026lt;\u0026lt; iota - 1\t// iota == 0, bit0 == 0001, mask == 0000  bit1, mask1\t// iota == 1, bit1 == 0010, mask == 0001  _, _\t// iota == 2  bit3, mask3\t// iota == 3, bit3 == 1000, mask == 0111 ) 2. iota 的取值规则 iota 的取值规则只有一条：iota 代表了 const 声明块的行索引（下标从 0 开始）。 const 声明的一个特点是，若为常量指定了一个表达式，而后续的常量没有表达式，则会继承上面的表达式。\n在单个const 声明块中，每增加一行声明，iota 的值增 1，即使声明中没有使用 iota。 由此也可知，在同一行中出现多个 iota，其取值是相同的。\nconst ( A = 100\t// iota == 0, A == 100  B\t// iota == 1, B == 100  C = iota\t// iota == 2, C == 2  D\t// iota == 3, D == 3  _\t// iota == 4  F\t// iota == 5, F == 5  G = 0\t// iota == 6, G == 0  H, I = 42 * iota, iota * iota + 3\t// iota == 7, H == 294, I == 52  J, K\t// iota == 8, J == 336, K == 67 ) ","permalink":"https://lachimere.github.io/posts/golang/%E7%90%86%E8%A7%A3iota%E7%9A%84%E5%8F%96%E5%80%BC%E8%A7%84%E5%88%99/","summary":"iota 的取值究竟是什么？","title":"理解 iota 的取值规则"},{"content":"1. Slice 定义 在 Go 的源码包中，src/runtime/slice.go 定义了 slice 的数据结构：\ntype slice struct { array unsafe.Pointer len int cap int } 其中，array 指向底层数组，len 为 slice 长度，cap 为底层数组容量。\n2. Slice 多种初始化方式的异同   使用变量声明\nvar s []int 当采用这种方式声明一个 slice 的时候，需要注意：\n s 是结构体 slice 的一个实例，其 fields 中 len 和 cap 均为 0，而 array 为 nil； 若输出 s，即 fmt.Println(s)，输出结果为 []； s == nil 为 true，但 \u0026amp;s 会显示一个有效的地址值，表明 s 已存在于内存中。    使用字面量初始化\n初始化一个空 slice：\ns := []int{} 此时，s 的 len 和 cap 也均为 0，但 array 不为 nil。虽然 fmt.Println(s) 仍会输出 []，但 s == nil 为 false。\n  使用内置函数 make() 可指定长度和空间\ns1 := make([]int, 5)\t// 指定长度 s2 := make([]int, 5, 10)\t// 指定长度和空间   从 array 或 slice 中切取\narr := [5]int{1, 2, 3, 4, 5} s1 := arr[0:2]\t// len(s1) == 2, cap(s1) == 5 s2 := s1[0:1]\t// len(s2) == 1, cap(s2) == 5 在本例中，s1 由 array arr 切取得到，s2 由 s1 切取得到，可验证 \u0026amp;arr == \u0026amp;s1[0] 和 \u0026amp;arr == \u0026amp;s2[0]。\n  3. 调用 append() 时需保持清醒 append() 扩容容量选择基于以下基本规则：\n 若 old.cap \u0026lt; 1024，则 slice 容量扩大为原来的 2 倍； 若 old.cap \u0026gt;= 1024，则 slice 容量扩大为原来的 1.25 倍。  在使用 append() 向 slice 中加入元素时，若 slice 空间不足，即当新加入的元素会使得 len \u0026gt; cap 时，slice 会通过 growslice() 函数增长。值得注意的是，growslice() 函数是有返回值的，其返回值类型为 slice，故可将 slice 的增长过程认为是在内存中的另一区域开辟一块新的空间存放数据，并将这块空间的地址作为新的 array 指针，同时更新 cap，构造出 slice{p, old.len, newcap} 以返回。因此，每一次扩容理论上都会引起 slice 底层数组所在位置的变化。\n一个很值得研究的例子如下：\nfunc SliceRise(s []int) { s = append(s, 0) for i := range s { s[i]++ } } func SlicePrint() { s1 := []int{1, 2} s2 := s1 s2 = append(s2, 3) SliceRise(s1) SliceRise(s2) fmt.Println(s1, s2)\t// [1 2] [2 3 4] } 当程序调用 SlicePrint() 函数时，该函数前两行执行后，s1 和 s2 是 len 和 cap 均为 2 的 两个 slices，debug 发现，此时有 \u0026amp;s1 != \u0026amp;s2 且 \u0026amp;s1[0] == \u0026amp;s2[0]，说明 s1 和 s2 是两个不同的 slice 实例，但二者的 array 值均相等。当向 s2 中加入元素 3 时，由于 s2 需要扩容，故 s2 的 array 值被更新（重新分配了新的空间）且其 len 和 cap 值由 2 分别更新为 3 和 4。\n现讨论 s1。切记，Go 语言中函数参数传递均是 pass by value，故调用 SliceRise(s1) 时，在 SliceRise() 中相当于进行了 s := s1 的操作，这与 SlicePrint() 中 s2 := s1 所造成的结果是一致的。故在 callee SliceRise() 中进行 s = append(s, 0) 操作后，s 的底层数组空间重新分配，不再代表其 caller SlicePrint() 中 s1 的底层数组，因此对其中所有元素的操作不会修改 s1 底层数组中元素的值，s1 最后的输出结果仍为 [1 2]。\ns2 的情况更加隐蔽。由上可知，在调用 SliceRise(s2) 之前，s2 的底层数组容量已更新为 4, 而此时其中有效元素仅有 1 和 2。同样地，SliceRise() 中的 s 是 s2 的拷贝，但由于 s2 底层数组中尚有空间存放新增的元素，此时 s = append(s, 0) 不会导致 array 所指空间的重新分配，即此时 s 和 s2 共享同一底层数组 ，故在 callee SliceRise() 中修改 s 中元素便是修改 caller SlicePrint() 中 s2 的底层数组元素。因此，caller 中 s2 底层数组的四个元素值分别更新为 2 3 4 1。但是，正是由于 pass by value，callee 中的 s 即使通过 append() 向 s2 的底层数组新加入了一个元素，其所更新的 len 是属于 s 的，这不会影响 caller 中 s2 的 len，故 s2 的 len 仍为 3，因此 s2 最后输出结果为 [2 3 4]。\n综上，即使有多个 slice 实例共享同一个底层数组，每个 slice 在进行 append() 操作时，只会修改其自身的 len 和 cap，且当其需要扩容时，只会将其与共享的底层数组解引用，并为其分配新的底层数组空间。在修改共享的底层数组元素时，会影响到所有共享此底层数组的 slice。\n","permalink":"https://lachimere.github.io/posts/golang/%E6%B7%B1%E5%85%A5%E8%AE%A8%E8%AE%BAslice/","summary":"对 slice 的初始化方式之间的异同点和调用 append() 的具体细节的一些讨论。","title":"深入讨论 Slice"}]